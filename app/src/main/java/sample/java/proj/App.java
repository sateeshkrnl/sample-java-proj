/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package sample.java.proj;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Collectors;

public class App {
    private static final Logger log = Logger.getLogger(App.class.getName());
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        log.info(new App().getGreeting());
        new App().isPossibleToSplit(new int[]{1,2,3,4,1,2,2});
    }

    static class User {
        private final int age;

        public User(int age) {
            this.age = age;
        }

        public int getAge() {
            return age;
        }

    }

    public boolean isPossibleToSplit(int[] nums) {
        Map<Integer,Integer> map = new HashMap<>();
        int [] part1 = new int[nums.length/2];
        int [] part2 = new int[nums.length/2];
        int j=0; 
        int k=0;
        for(int i=0;i<nums.length;i++){
            map.merge(nums[i], 1, (o,n)->o+n);
        }
        log.log(Level.INFO, "map output {0}", map);
        if(nums.length%2!=0){
            return false;
        }else{
            if(map.values().stream().anyMatch(i->i>2)){
                return false;
            }else{
                return populatePartArrays(map, part1, part2, j, k);
            }
        }
    }

    private boolean populatePartArrays(Map<Integer, Integer> map, int[] part1, int[] part2, int j, int k) {
        boolean part1used=false;
        for(Map.Entry<Integer,Integer> entry: map.entrySet()){
            if(entry.getValue()==2){
                part1[j++]=entry.getKey();
                part2[k++]=entry.getKey();
            }else{
                if(!part1used){
                    part1[j++]=entry.getKey();
                    part1used=true;
                }else {
                    part2[k++]=entry.getKey();
                    part1used=false;
                }
            }
        }
        log.log(Level.INFO, "part1 output {0}", part1);
        log.log(Level.INFO, "part2 output {0}", part2);
        return true;
    }

    public int[] arraySort(int[] nums){
        List<Integer> numList = new ArrayList<>();
        Arrays.stream(nums).forEach(numList::add);
        return numList.stream().sorted((i,r)->{
            if(i==0)
             return 1;
            if(r==0)
             return -1; 
            return 0;
        }).mapToInt(i->i).toArray();
    }

    public int[] findIndexesWithCount(int[] nums,int sum){
        int[] index = new int[2];
        boolean found=false;
        for(int i=0;i<nums.length;i++){
            int j=0;
            for(j=i+1;j<nums.length;j++){
                if(nums[i]+nums[j]==sum){
                    index[0]=i;
                    index[1]=j;
                    found=true;
                    break;
                }
            }
            if(found)
                break;
        }
        return index;
    }

    public int[] selectionSortArray(int[] arr){
        for(int i=0;i<arr.length-1;i++){
            int minidx=i;
            for(int j=i+1;j<arr.length;j++){
                if(arr[minidx]>arr[j]){
                    minidx=j;
                }
            }
            int temp=arr[minidx];
            arr[minidx]=arr[i];
            arr[i]=temp;
        }
        return arr;
    }

    public BigInteger factorialUsingLoop(int x){
        BigInteger out=BigInteger.valueOf(1);
        for(int i=1;i<=x;i++){
            out=out.multiply(BigInteger.valueOf(i));
        }
        return out;
    }

    public BigInteger factorialusingRecursion(BigInteger x){
        if(x.equals(BigInteger.valueOf(1))){
         return x;
        } 
        return x.multiply(factorialusingRecursion(x.subtract(BigInteger.valueOf(1))));
    }

    public String convertInttoBinary(int x){
        return Integer.toBinaryString(x);
    }

    public String convertInttoBinaryUsingRecurssion(int x){
        StringBuilder builder = new StringBuilder("");
        convertInttoBinaryUsingRecurssion(x,builder);
        return builder.reverse().toString();
    }

    private void convertInttoBinaryUsingRecurssion(int x,StringBuilder output){
        int div = x/2;        
        int mod = x%2;
        output.append(Integer.toString(mod));
        if(div==0){
            return;
        }
        convertInttoBinaryUsingRecurssion(div,output);
    }

    public int sumofArray(int[] nums){
        int i=0;
        for(int num:nums){
            i+=num;
        }
        return i;
    }

    public int[] arrayRotationRight(int[] nums,int step){
        int[] output=new int[nums.length];
        int j=nums.length-step;
        for(int i=0;i<nums.length && j<nums.length;i++){
            output[i]=nums[j];
            if(++j>=nums.length){
                j=0;
            }
        }
        return output;
    }

    public int[] arrayRotationLeft(int[] nums,int step){
        int[] output=new int[nums.length];
        int j=step;
        for(int i=0;i<nums.length && j<nums.length;i++){
            output[i]=nums[j];
            if(++j>=nums.length){
                j=0;
            }
        }
        return output;
    }
}
